*** Get Inventory With Db Query
Fishbowl::Connection.connect
Fishbowl::Connection.login
builder = Nokogiri::XML::Builder.new do |xml|
  xml.request {
    xml. ExecuteQueryRq {
      xml.Query "SELECT Product.num,QtyInventoryTotals.* FROM QtyInventoryTotals INNER JOIN Part ON QtyInventoryTotals.partId = Part.id INNER JOIN Product ON Part.id = Product.partId WHERE QtyInventoryTotals.LOCATIONGROUPID=1"
    }
  }
end
code, response = Fishbowl::Objects::BaseObject.new.send_request(builder, "ProductGetRs")
Fishbowl::Connection.close
product_inventory={}
response.xpath("//Row")[1..-1].each do |row|
    row_array=row.inner_html.split(',').map{|x| x.gsub("\"","")}
    qty_on_hand = row_array[3]
    qty_allocated = row_array[4]
    qty_not_available = row_array[5]
    product_inventory["#{row_array[0]}"] = qty_on_hand.to_i - qty_allocated.to_i - qty_not_available.to_i
end

qty_pickable =   qty_on_hand - qty_allocatated - qty_not_available


response.xpath("//Row")[0]
response.xpath("//Row")[1]

***

customers=Customer.create_from_open_orders
customers.each do |customer|
    customer.create_sales_orders
end

customers=Customer.create_from_open_orders
customer.create_sales_orders
customer.needs_consolidation?
orders=customer.consolidated_orders

orders[:not_pickable].sales_order_items.each do |i|  
    puts "#{i.product_num}, #{i.qty_to_fulfill}"
end
orders[:pickable].sales_order_items.each do |i|  
    puts "#{i.product_num}, #{i.qty_to_fulfill}"
end

***
oc=OrderConsolidation.find_by_id 3
c=oc.customers.second
c.create_sales_orders

*** Items on same order that have same number one pickable one not are being merged

PICKABLE
C502, 25 OKAY
CR401, 25 (should be split)
CR403, 25 OKAY
CR402, 25 OKAY
C501, 25 NOT PICKALBE
iEdge, 8 OKAY

NOT PICKABLE
BB2011, 1 RIGHT
iEdge, 2 OKAY

***

sales_orders=SalesOrder.find_open_orders
builder=sales_orders[0].xml_builder
Fishbowl::Connection.connect
Fishbowl::Connection.login
code, response = Fishbowl::Objects::BaseObject.new.send_request(builder, "ProductGetRs")
Fishbowl::Connection.close


sales_orders=SalesOrder.find_open_orders
sales_orders.each do |sales_order|
    puts "SALES ORDER: #{sales_order.num}"
end


Fishbowl::Connection.connect
Fishbowl::Connection.login
builder = Nokogiri::XML::Builder.new do |xml|
  xml.request {
    xml. InvQtyRq {
      xml.PartNum 'BB2001'
    }
  }
end
code, response = Fishbowl::Objects::BaseObject.new.send_request(builder, "ProductGetRs")
Fishbowl::Connection.close

*** GetSoList
Fishbowl::Connection.connect
Fishbowl::Connection.login
builder = Nokogiri::XML::Builder.new do |xml|
  xml.request {
    xml. GetSOListRq {
      xml.Status 'All Open'
    }
  }
end
code, response = Fishbowl::Objects::BaseObject.new.send_request(builder, "ProductGetRs")
Fishbowl::Connection.close



request=Nokogiri::XML::Builder.new do |xml|
      xml.request {
        xml.VoidSORq {
          xml.SONumber 50053
        }
      }
    end
    
    Fishbowl::Objects::BaseObject.new.send_request(request, 'VoidSORs')
    
    
    

request=Nokogiri::XML::Builder.new do |xml|
        xml.request {
            xml.AddSOItemRq {
                xml.OrderNum 50055
                xml.SalesOrderItem {
                    xml.ID -1
                    xml.ProductNumber 'BTY100-Core'
                    xml.SOID 94
                    xml.Description 'Battery Pack'
                    xml.Taxable true
                    xml.Quantity 1
                    xml.ProductPrice -95.00
                    xml.TotalPrice -95.00
                    xml.UOMCode 'ea'
                    xml.ItemType 20
                    xml.Status 10
                    xml.QuickBooksClassName 'Salt Lake City'
                    xml.DateScheduledFulfillment '2018-05-18 14 02 21'
                    xml.NewItemFlag false
                }
            }
        }
    end

Fishbowl::Objects::BaseObject.new.send_request(request, 'AddSOItemRs')


Fishbowl::Connection.connect
Fishbowl::Connection.login